# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.38
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        try:
            fp, pathname, description = imp.find_module('_dparser', [dirname(__file__)])
            _mod = imp.load_module('_dparser', fp, pathname, description)
        finally:
            if fp is not None: fp.close()
        return _mod
    _dparser = swig_import_helper()
    del swig_import_helper
else:
    import _dparser
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class user_pyobjects(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, user_pyobjects, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, user_pyobjects, name)
    __repr__ = _swig_repr
    __swig_setmethods__["t"] = _dparser.user_pyobjects_t_set
    __swig_getmethods__["t"] = _dparser.user_pyobjects_t_get
    if _newclass:t = _swig_property(_dparser.user_pyobjects_t_get, _dparser.user_pyobjects_t_set)
    __swig_setmethods__["s"] = _dparser.user_pyobjects_s_set
    __swig_getmethods__["s"] = _dparser.user_pyobjects_s_get
    if _newclass:s = _swig_property(_dparser.user_pyobjects_s_get, _dparser.user_pyobjects_s_set)
    __swig_setmethods__["inced_global_state"] = _dparser.user_pyobjects_inced_global_state_set
    __swig_getmethods__["inced_global_state"] = _dparser.user_pyobjects_inced_global_state_get
    if _newclass:inced_global_state = _swig_property(_dparser.user_pyobjects_inced_global_state_get, _dparser.user_pyobjects_inced_global_state_set)
    def __init__(self): 
        this = _dparser.new_user_pyobjects()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _dparser.delete_user_pyobjects
    __del__ = lambda self : None;
user_pyobjects_swigregister = _dparser.user_pyobjects_swigregister
user_pyobjects_swigregister(user_pyobjects)

class d_loc_t(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, d_loc_t, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, d_loc_t, name)
    __repr__ = _swig_repr
    __swig_setmethods__["pathname"] = _dparser.d_loc_t_pathname_set
    __swig_getmethods__["pathname"] = _dparser.d_loc_t_pathname_get
    if _newclass:pathname = _swig_property(_dparser.d_loc_t_pathname_get, _dparser.d_loc_t_pathname_set)
    __swig_setmethods__["previous_col"] = _dparser.d_loc_t_previous_col_set
    __swig_getmethods__["previous_col"] = _dparser.d_loc_t_previous_col_get
    if _newclass:previous_col = _swig_property(_dparser.d_loc_t_previous_col_get, _dparser.d_loc_t_previous_col_set)
    __swig_setmethods__["col"] = _dparser.d_loc_t_col_set
    __swig_getmethods__["col"] = _dparser.d_loc_t_col_get
    if _newclass:col = _swig_property(_dparser.d_loc_t_col_get, _dparser.d_loc_t_col_set)
    __swig_setmethods__["line"] = _dparser.d_loc_t_line_set
    __swig_getmethods__["line"] = _dparser.d_loc_t_line_get
    if _newclass:line = _swig_property(_dparser.d_loc_t_line_get, _dparser.d_loc_t_line_set)
    def __init__(self): 
        this = _dparser.new_d_loc_t()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _dparser.delete_d_loc_t
    __del__ = lambda self : None;
d_loc_t_swigregister = _dparser.d_loc_t_swigregister
d_loc_t_swigregister(d_loc_t)

class D_ParseNode(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, D_ParseNode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, D_ParseNode, name)
    __repr__ = _swig_repr
    __swig_setmethods__["symbol"] = _dparser.D_ParseNode_symbol_set
    __swig_getmethods__["symbol"] = _dparser.D_ParseNode_symbol_get
    if _newclass:symbol = _swig_property(_dparser.D_ParseNode_symbol_get, _dparser.D_ParseNode_symbol_set)
    __swig_setmethods__["start_loc"] = _dparser.D_ParseNode_start_loc_set
    __swig_getmethods__["start_loc"] = _dparser.D_ParseNode_start_loc_get
    if _newclass:start_loc = _swig_property(_dparser.D_ParseNode_start_loc_get, _dparser.D_ParseNode_start_loc_set)
    __swig_setmethods__["globals"] = _dparser.D_ParseNode_globals_set
    __swig_getmethods__["globals"] = _dparser.D_ParseNode_globals_get
    if _newclass:globals = _swig_property(_dparser.D_ParseNode_globals_get, _dparser.D_ParseNode_globals_set)
    __swig_setmethods__["user"] = _dparser.D_ParseNode_user_set
    __swig_getmethods__["user"] = _dparser.D_ParseNode_user_get
    if _newclass:user = _swig_property(_dparser.D_ParseNode_user_get, _dparser.D_ParseNode_user_set)
    def __init__(self): 
        this = _dparser.new_D_ParseNode()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _dparser.delete_D_ParseNode
    __del__ = lambda self : None;
D_ParseNode_swigregister = _dparser.D_ParseNode_swigregister
D_ParseNode_swigregister(D_ParseNode)


def d_get_child(*args):
  return _dparser.d_get_child(*args)
d_get_child = _dparser.d_get_child

def d_find_in_tree(*args):
  return _dparser.d_find_in_tree(*args)
d_find_in_tree = _dparser.d_find_in_tree

def d_get_number_of_children(*args):
  return _dparser.d_get_number_of_children(*args)
d_get_number_of_children = _dparser.d_get_number_of_children

def my_d_loc_t_s_set(*args):
  return _dparser.my_d_loc_t_s_set(*args)
my_d_loc_t_s_set = _dparser.my_d_loc_t_s_set

def my_d_loc_t_s_get(*args):
  return _dparser.my_d_loc_t_s_get(*args)
my_d_loc_t_s_get = _dparser.my_d_loc_t_s_get

def my_D_ParseNode_end_set(*args):
  return _dparser.my_D_ParseNode_end_set(*args)
my_D_ParseNode_end_set = _dparser.my_D_ParseNode_end_set

def my_D_ParseNode_end_skip_set(*args):
  return _dparser.my_D_ParseNode_end_skip_set(*args)
my_D_ParseNode_end_skip_set = _dparser.my_D_ParseNode_end_skip_set

def my_D_ParseNode_end_get(*args):
  return _dparser.my_D_ParseNode_end_get(*args)
my_D_ParseNode_end_get = _dparser.my_D_ParseNode_end_get

def my_D_ParseNode_end_skip_get(*args):
  return _dparser.my_D_ParseNode_end_skip_get(*args)
my_D_ParseNode_end_skip_get = _dparser.my_D_ParseNode_end_skip_get

def my_D_ParseNode_symbol_get(*args):
  return _dparser.my_D_ParseNode_symbol_get(*args)
my_D_ParseNode_symbol_get = _dparser.my_D_ParseNode_symbol_get

def remove_parse_tree_viewer(*args):
  return _dparser.remove_parse_tree_viewer(*args)
remove_parse_tree_viewer = _dparser.remove_parse_tree_viewer

def add_parse_tree_viewer(*args):
  return _dparser.add_parse_tree_viewer(*args)
add_parse_tree_viewer = _dparser.add_parse_tree_viewer

def del_parser(*args):
  return _dparser.del_parser(*args)
del_parser = _dparser.del_parser

def make_parser(*args):
  return _dparser.make_parser(*args)
make_parser = _dparser.make_parser

def run_parser(*args):
  return _dparser.run_parser(*args)
run_parser = _dparser.run_parser

def make_tables(*args):
  return _dparser.make_tables(*args)
make_tables = _dparser.make_tables

def load_parser_tables(*args):
  return _dparser.load_parser_tables(*args)
load_parser_tables = _dparser.load_parser_tables


# Copyright (c) 2003, 2004 Brian Sabbey
# contributions by Milosz Krajewski

import sys, types, os, md5, string

#class user_pyobjectsPtr :
#    def __init__(self,this):
#        self.this = this
#        self.thisown = 0
#    def __setattr__(self,name,value):
#        if name == "t" :
#            _dparser.user_pyobjects_t_set(self.this,value)
#            return
#        self.__dict__[name] = value
#    def __getattr__(self,name):
#        if name == "t" : 
#            return _dparser.user_pyobjects_t_get(self.this)
#        raise AttributeError,name
#    def __repr__(self):
#        return "<C user_pyobjects instance>"
#   
#class user_pyobjects(user_pyobjectsPtr):
#    def __init__(self,this):
#        self.this = this

class d_loc_tPtr_ :
    def __init__(self, this, d_parser):
        self.this = this
        self.thisown = 0
        self.d_parser = d_parser
    def __setattr__(self, name, value):
        if name == "s" :
            _dparser.my_d_loc_t_s_set(self.this,self.d_parser,value)
            return
        if name == "pathname" :
            _dparser.d_loc_t_pathname_set(self.this,value)
            return
        if name == "previous_col" :
            _dparser.d_loc_t_previous_col_set(self.this,value)
            return
        if name == "col" :
            _dparser.d_loc_t_col_set(self.this,value)
            return
        if name == "line" :
            _dparser.d_loc_t_line_set(self.this,value)
            return
        self.__dict__[name] = value
    def __getattr__(self, name):
        if name == "s" : 
            return _dparser.my_d_loc_t_s_get(self.this,self.d_parser)
        if name == "pathname" : 
            return _dparser.d_loc_t_pathname_get(self.this)
        if name == "previous_col" : 
            return _dparser.d_loc_t_previous_col_get(self.this)
        if name == "col" : 
            return _dparser.d_loc_t_col_get(self.this)
        if name == "line" : 
            return _dparser.d_loc_t_line_get(self.this)
        raise AttributeError,name
    def __repr__(self):
        return "<C d_loc_t instance>"
    
#class d_loc_t(d_loc_tPtr):
#    def __init__(self, this, d_parser, buf):
#        self.this = this
#        self.d_parser = d_parser
#        self.buf = buf
        
class D_ParseNodePtr_ :
    def __init__(self, this):
        self.this = this
        self.thisown = 0
    def __setattr__(self, name, value):
        if name == "start_loc" :
            _dparser.D_ParseNode_start_loc_set(self.this,value.this)
            return
        if name == "end" :
            _dparser.my_D_ParseNode_end_set(self.this,self.d_parser,value)
            return
        if name == "end_skip" :
            _dparser.my_D_ParseNode_end_skip_set(self.this,self.d_parser,value)
            return
        if name == "globals" :
            _dparser.D_ParseNode_globals_set(self.this,value)
            return
        if name == "user" :
            _dparser.D_ParseNode_user_set(self.this,value.this)
            return
        self.__dict__[name] = value
    def __getattr__(self, name):
        if name == "symbol" : 
            return _dparser.my_D_ParseNode_symbol_get(self.this,self.d_parser)
        if name == "end" : 
            return _dparser.my_D_ParseNode_end_get(self.this,self.d_parser)
        if name == "end_skip" : 
            return _dparser.my_D_ParseNode_end_skip_get(self.this,self.d_parser)
        if name == "globals" : 
            return _dparser.D_ParseNode_globals_get(self.this)
        if name == "user" : 
            return user_pyobjectsPtr(_dparser.D_ParseNode_user_get(self.this))
        if name == "start_loc" :
            val = self.__dict__.get("start_loc")
            if not val:
                val = self.__dict__["start_loc"] = d_loc_t(_dparser.D_ParseNode_start_loc_get(self.this), self.d_parser, self.buf)
            return val
        if name == "c":
            val = self.__dict__.get("c", None)
            if not val:
                nc = _dparser.d_get_number_of_children(self.this)
                val = self.__dict__["c"] = [None]*nc
                for i in range(0, nc):
                    val[i] = D_ParseNode(_dparser.d_get_child(self.this, i), self.d_parser, self.buf)
            return val
        raise AttributeError,name
    def __repr__(self):
        return "<C D_ParseNode instance>"
    
#class D_ParseNode(D_ParseNodePtr):
#    def __del__(self):
#        if _dparser:
#            _dparser.remove_parse_tree_viewer(self.d_parser)
#    def __init__(self, this, d_parser, buf):
#        self.this = this
#        self.d_parser = d_parser
#        self.buf = buf
#        _dparser.add_parse_tree_viewer(self.d_parser)

class Reject: pass

class SyntaxError(Exception):
    pass
class AmbiguityException(Exception):
    pass

def my_syntax_error_func(loc):
    ee = '...'
    be = '...'
    width = 25
    mn = loc.s - width
    if mn < 0:
        mn = 0
        be = ''
    mx = loc.s + 25
    if mx > len(loc.buf):
        mx = len(loc.buf)
        ee = ''
    begin = loc.buf[mn:loc.s]
    end = loc.buf[loc.s:mx]
    string = '\n\nsyntax error, line:' + str(loc.line) + '\n\n' + be + begin +  '[syntax error]' + end + ee + '\n'
    raise SyntaxError, string

def my_ambiguity_func(nodes):
    raise AmbiguityException, "\nunresolved ambiguity.  Symbols:\n" + string.join([node.symbol for node in nodes], "\n")

loaded_tables = {}

class Parser:
    def __init__(self, modules=None, file_prefix="d_parser_mach_gen",make_grammar_file=0):
        self.file_prefix = file_prefix
        self.actions = []
        sig = md5.new()
        sig.update('1.13')
        if not modules:
            try:
                raise RuntimeError
            except RuntimeError:
                e,b,t = sys.exc_info()
            
            dicts = [t.tb_frame.f_back.f_globals]
        else:
            if type(modules) == list:
                dicts = [module.__dict__ for module in modules]
            else:
                dicts = [modules.__dict__]
                
        functions = []
        for dict in dicts:
            f = [val for name, val in dict.items() 
                 if (isinstance(val, types.FunctionType)) and name[0:2] == 'd_']
            f.sort(lambda x, y: cmp(x.func_code.co_filename, y.func_code.co_filename) or cmp(x.func_code.co_firstlineno, y.func_code.co_firstlineno))
            functions.extend(f)
        if len(functions) == 0:
            raise "\nno actions found.  Action names must start with 'd_'"
        
        app_path = os.path.dirname(sys.argv[0])
        if len(app_path) == 0:
            app_path = os.getcwd()
        app_path = string.replace(app_path, '\\', '/')
        self.filename = app_path + '/' + self.file_prefix + ".g"
        
        grammar_str = []
        self.takes_strings = 0
        self.takes_globals = 0
        for f in functions:
            if f.__doc__:
                grammar_str.append(f.__doc__) 
                sig.update(f.__doc__)
            else:
                raise "\naction missing doc string:\n\t" + f.__name__
            grammar_str.append(" ${action};\n")
            if f.func_code.co_argcount == 0:
                raise "\naction " + f.__name__ + " must take at least one argument\n"
            speculative = 0
            arg_types = [0]
            for i in range(1, f.func_code.co_argcount):
                var = f.func_code.co_varnames[i]
                if var == 'spec':
                    arg_types.append(1)
                    speculative = 1
                elif var == 'g':
                    arg_types.append(2)
                    self.takes_globals = 1
                elif var == 's':
                    arg_types.append(3)
                    self.takes_strings = 1
                elif var == 'nodes':
                    arg_types.append(4)
                elif var == 'this':
                    arg_types.append(5)
                elif var == 'spec_only':
                    arg_types.append(6)
                    speculative = -1
                elif var == 'parser':
                    arg_types.append(7)
                else:
                    raise "\nunknown argument name:\n\t" + var + "\nin function:\n\t" + f.__name__
            self.actions.append((f, arg_types, speculative))
        grammar_str = string.join(grammar_str, '')
        
        if make_grammar_file:
            g_file = open(self.filename, "wb") # 'binary' mode has been set to force \n on end of the line
            g_file.write(grammar_str)
            g_file.close()
            
        if self.sig_changed(sig):
            _dparser.make_tables(grammar_str, self.filename)
            sig_file = open(self.filename + ".md5", "w")
            sig_file.write("%s\n" % repr(sig.digest()))
            sig_file.close()

        global loaded_tables # todo: free tables in __del__ instead of this hack
        self.tables = loaded_tables.get(sig.digest(), None)
        if not self.tables:
            self.tables = _dparser.load_parser_tables(self.filename + ".d_parser.dat")
            loaded_tables[sig.digest()] = self.tables
            
    def sig_changed(self, sig):
        try:
            sig_file = open(self.filename + ".md5", "r")
            line = sig_file.readline()
            sig_file.close()
            if line and eval(line) == sig.digest():
                return 0
        except IOError, SyntaxError:
            pass
        return 1

    def parse(self, buf, buf_offset=0,
              initial_skip_space_fn=None,
              syntax_error_fn=my_syntax_error_func, ambiguity_fn=my_ambiguity_func,
              make_token=None,
              dont_fixup_internal_productions=0,
              dont_merge_epsilon_trees=0,
              commit_actions_interval=0,
              error_recovery=0,
              print_debug_info=0,
              partial_parses=0,
              dont_compare_stacks=0,
              dont_use_eagerness_for_disambiguation=0,
              dont_use_height_for_disambiguation=0,
              start_symbol=''):
        parser = _dparser.make_parser(self.tables, self, Reject, make_token, d_loc_t, D_ParseNode,
                                           self.actions, initial_skip_space_fn, syntax_error_fn,
                                           ambiguity_fn, dont_fixup_internal_productions,
                                           dont_merge_epsilon_trees,
                                           commit_actions_interval,
                                           error_recovery,
                                           print_debug_info,
                                           partial_parses,
                                           dont_compare_stacks,
                                           dont_use_eagerness_for_disambiguation,
                                           dont_use_height_for_disambiguation,
                                           start_symbol, self.takes_strings, self.takes_globals)
        result = _dparser.run_parser(parser, buf, buf_offset)
        if result == None:
            return None
        if len(result) == 3:
            self.s = result[2]
        self.top_node = result[1]
        return result[0]



# python-mode
