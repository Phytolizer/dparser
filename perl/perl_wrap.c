/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2205 from the
 * contents of D.xs. Do not edit this file, edit D.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "D.xs"
/* 
 * $Id: D.xs,v 1.1.1.1 2010-05-27 15:29:30 cmont Exp $ 
 *
 * $Log: D.xs,v $
 * Revision 1.1.1.1  2010-05-27 15:29:30  cmont
 * the da-parser with perl module
 *
 *
 */

#include "Dxs.c"

#
#
#
#
#
#
#
#
#
# 

#line 34 "D.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 86 "D.c"

XS(XS_D_ParserTablesPtr_free); /* prototype to pass -Wmissing-prototypes */
XS(XS_D_ParserTablesPtr_free)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	D_ParserTables*	p;

	if (sv_derived_from(ST(0), "D_ParserTablesPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(D_ParserTables *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"D_ParserTablesPtr::free",
			"p", "D_ParserTablesPtr");
#line 30 "D.xs"
  warn("==free tbl@%x", p);
  // creates havocs... at final global release
  // must have been already freed? but where?
  //FREE(p);
#line 114 "D.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_D_ParserTablesPtr_dump); /* prototype to pass -Wmissing-prototypes */
XS(XS_D_ParserTablesPtr_dump)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dpt");
    {
	D_ParserTables*	dpt;
#line 40 "D.xs"
  STRLEN count_charPtrPtr = 0x001a;
#line 134 "D.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "D_ParserTablesPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dpt = INT2PTR(D_ParserTables *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"D_ParserTablesPtr::dump",
			"dpt", "D_ParserTablesPtr");
#line 42 "D.xs"
  RETVAL = newSVpvn((char*)dpt, count_charPtrPtr);
#line 147 "D.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_D_ParserTablesPtr_symbol_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_D_ParserTablesPtr_symbol_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "dpt, i");
    {
	D_ParserTables*	dpt;
	int	i = (int)SvIV(ST(1));
	char *	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "D_ParserTablesPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dpt = INT2PTR(D_ParserTables *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"D_ParserTablesPtr::symbol_name",
			"dpt", "D_ParserTablesPtr");
#line 52 "D.xs"
	warn("==table_symbol_string get");
        RETVAL = dpt->symbols[i].name;
#line 182 "D.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Parser__D__Tables_read_binary); /* prototype to pass -Wmissing-prototypes */
XS(XS_Parser__D__Tables_read_binary)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "tables_name");
    {
	char*	tables_name = (char *)SvPV_nolen(ST(0));
	D_ParserTables *	RETVAL;
#line 65 "D.xs"
     RETVAL = read_binary_tables(tables_name, NULL, NULL);
#line 204 "D.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "D_ParserTablesPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Parser__D__Tables_read_binary_from_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Parser__D__Tables_read_binary_from_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "tables_name");
    {
	FILE*	tables_name = PerlIO_findFILE(IoIFP(sv_2io(ST(0))));
	D_ParserTables *	RETVAL;
#line 75 "D.xs"
        RETVAL = read_binary_tables_from_file(tables_name,  NULL, NULL);
#line 227 "D.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "D_ParserTablesPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Parser__D__Tables_read_binary_from_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_Parser__D__Tables_read_binary_from_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "tables_name");
    {
	unsigned char*	tables_name = (unsigned char *)SvPV_nolen(ST(0));
	D_ParserTables *	RETVAL;
#line 84 "D.xs"
     RETVAL = read_binary_tables_from_string(tables_name,  NULL, NULL);
#line 250 "D.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "D_ParserTablesPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Parser__D__d_loc_t_s_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Parser__D__d_loc_t_s_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	HV*	s;
#line 107 "D.xs"
	d_loc_t* loc;
	char* buf_start;
#line 273 "D.c"
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    s = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"Parser::D::d_loc_t::s_get",
			"s");
#line 110 "D.xs"
	loc = INT2PTR(d_loc_t*, SvIV(SvRV(*__hvSV(s, this))));
	buf_start = SvPV_nolen(SvRV(*hv_fetch(s, "buf", 3, 0)));
	RETVAL = loc->s - buf_start;		
	if(loc->s == NULL || RETVAL > 0x8fffffff) {
	  warn("<=d_loc_t_s_get::ERROR::\t\tloc@%x pos=(loc.s%x - buf%x)%x:\n"
	       , loc, loc->s, buf_start, RETVAL);
	  RETVAL = 0; 
	}
#line 292 "D.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Parser__D__d_loc_t_s_set); /* prototype to pass -Wmissing-prototypes */
XS(XS_Parser__D__d_loc_t_s_set)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, l");
    {
	HV*	s;
	STRLEN	l = (STRLEN)SvUV(ST(1));
#line 128 "D.xs"
	d_loc_t* loc;
	char* buf_start;
#line 315 "D.c"
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    s = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"Parser::D::d_loc_t::s_set",
			"s");
#line 131 "D.xs"
	loc = INT2PTR(d_loc_t*, SvIV(SvRV(*__hvSV(s, this))));
	buf_start = SvPV_nolen(SvRV(*__hvSV(s, buf)));
	loc->s = buf_start + l;
	DBG2(warn("==d_loc_t_s_set\t\ts-buf@%x=(loc.s*%x - buf*%x):\n", loc, loc->s, buf_start));
	RETVAL = l;
#line 331 "D.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Parser__D__d_loc_t_col_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Parser__D__d_loc_t_col_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	HV*	s;
#line 144 "D.xs"
	d_loc_t* loc;
#line 352 "D.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    s = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"Parser::D::d_loc_t::col_get",
			"s");
#line 146 "D.xs"
	loc = INT2PTR(d_loc_t*, SvIV(SvRV(*__hvSV(s, this))));
	DBG2(warn("==d_loc_t_s_get\t\ts-buf@%x=(loc.s*%x)\n", loc, loc->s));
	RETVAL = loc->col;
#line 366 "D.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Parser__D__d_loc_t_line_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Parser__D__d_loc_t_line_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "s");
    {
	HV*	s;
#line 157 "D.xs"
	d_loc_t* loc;
#line 387 "D.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    s = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"Parser::D::d_loc_t::line_get",
			"s");
#line 159 "D.xs"
	loc = INT2PTR(d_loc_t*, SvIV(SvRV(*__hvSV(s, this))));
	RETVAL = loc->line;
#line 400 "D.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_D_ParseNodePtr_children_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_D_ParseNodePtr_children_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dpn");
    {
	D_ParseNode*	dpn;
#line 183 "D.xs"
	PNode* pn;
#line 421 "D.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "D_ParseNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dpn = INT2PTR(D_ParseNode *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"D_ParseNodePtr::children_list",
			"dpn", "D_ParseNodePtr");
#line 185 "D.xs"
	pn = D_ParseNode_to_PNode(dpn);
	RETVAL = make_pnode_list(&(pn->children.v[0]), d_get_number_of_children(dpn));
#line 435 "D.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_D_ParseNodePtr_user); /* prototype to pass -Wmissing-prototypes */
XS(XS_D_ParseNodePtr_user)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "pn, ...");
    if (items == 2)
    {
	D_ParseNode*	pn;
#line 198 "D.xs"
	SV* val;
#line 458 "D.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "D_ParseNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pn = INT2PTR(D_ParseNode *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"D_ParseNodePtr::user",
			"pn", "D_ParseNodePtr");
#line 200 "D.xs"
	val = SvREFCNT_inc(ST(1));
        pn->user.pl = newSVsv(val);
        RETVAL = val;
	DBG(3, warn("<=dpn_user put\t\t\tdpn@%x user*%x<#%i\n"
			, pn, pn->user.pl, SvREFCNT(pn->user.pl)));
#line 475 "D.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    else
    {
	D_ParseNode*	pn;
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "D_ParseNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pn = INT2PTR(D_ParseNode *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"D_ParseNodePtr::user",
			"pn", "D_ParseNodePtr");
#line 210 "D.xs"
	DBG(3, warn("=>dpn_user get\t\t\tdpn@%x user*%x\n", pn, pn->user.pl));
        if(pn->user.pl == Nullsv) {
	  XSRETURN_UNDEF;
	} else {
	  /*fails with SvRV no_inc newSV SvREFCNT_inc
	   * newRV refers itself!
	   * in fact RV(pn->user.pl) mortalises and when goes out of scope
	   * of ::Table.. it would disappears!
	   */
	  RETVAL = newSVsv(pn->user.pl);
	  DBG(1, warn("<=dpn_user get\t\t\tdpn@%x user@%x<#%i~@%x\n"
		   , pn, pn->user.pl, SvREFCNT(pn->user.pl), RETVAL)
	      );
	}
#line 507 "D.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_D_ParseNodePtr_action_index); /* prototype to pass -Wmissing-prototypes */
XS(XS_D_ParseNodePtr_action_index)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dpn");
    {
	D_ParseNode*	dpn;
#line 232 "D.xs"
	D_Reduction* r;
#line 529 "D.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "D_ParseNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dpn = INT2PTR(D_ParseNode *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"D_ParseNodePtr::action_index",
			"dpn", "D_ParseNodePtr");
#line 234 "D.xs"
	r = D_ParseNode_to_PNode(dpn)->reduction;
	if(r) {
	  if(r->action_index >= 0) {
	    RETVAL = r->action_index;
	  } else {
	    RETVAL = (unsigned int)r->final_code + (unsigned int)r->speculative_code;
	  }
	} else {
	  RETVAL = -1;
	}
#line 552 "D.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_D_ParseNodePtr_speculative_code); /* prototype to pass -Wmissing-prototypes */
XS(XS_D_ParseNodePtr_speculative_code)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dpn");
    {
	D_ParseNode*	dpn;
#line 251 "D.xs"
	D_Reduction* r;
#line 573 "D.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "D_ParseNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dpn = INT2PTR(D_ParseNode *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"D_ParseNodePtr::speculative_code",
			"dpn", "D_ParseNodePtr");
#line 253 "D.xs"
	r = D_ParseNode_to_PNode(dpn)->reduction;
	if(r) {
	  RETVAL = (unsigned int)r->speculative_code;
	} else {
	  RETVAL = -1;
	}
#line 592 "D.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_D_ParseNodePtr_final_code); /* prototype to pass -Wmissing-prototypes */
XS(XS_D_ParseNodePtr_final_code)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dpn");
    {
	D_ParseNode*	dpn;
#line 266 "D.xs"
	D_Reduction* r;
#line 613 "D.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "D_ParseNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dpn = INT2PTR(D_ParseNode *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"D_ParseNodePtr::final_code",
			"dpn", "D_ParseNodePtr");
#line 268 "D.xs"
	r = D_ParseNode_to_PNode(dpn)->reduction;
	if(r) {
	  RETVAL = (unsigned int)r->final_code;
	} else {
	  RETVAL = -1;
	}
#line 632 "D.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_D_ParseNodePtr_symbol); /* prototype to pass -Wmissing-prototypes */
XS(XS_D_ParseNodePtr_symbol)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "pn, ...");
    if (items == 2)
    {
	D_ParseNode*	pn;
#line 283 "D.xs"
	int val = (int)SvIV(ST(1));
#line 654 "D.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "D_ParseNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pn = INT2PTR(D_ParseNode *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"D_ParseNodePtr::symbol",
			"pn", "D_ParseNodePtr");
#line 285 "D.xs"
	DBG(1, warn("==dpn_symbol put\n"));
	SvREFCNT_dec(pn->symbol);
        pn->symbol = val;
	RETVAL = val;
#line 671 "D.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    else
    {
	D_ParseNode*	pn;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "D_ParseNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pn = INT2PTR(D_ParseNode *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"D_ParseNodePtr::symbol",
			"pn", "D_ParseNodePtr");
#line 294 "D.xs"
	DBG(1, warn("==dpn_symbol get"));
	RETVAL = pn->symbol;
#line 691 "D.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_D_ParseNodePtr_val); /* prototype to pass -Wmissing-prototypes */
XS(XS_D_ParseNodePtr_val)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dpn");
    {
	D_ParseNode*	dpn;
#line 305 "D.xs"
	char*	start;
	char*	end;
	STRLEN 	len;
#line 714 "D.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "D_ParseNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dpn = INT2PTR(D_ParseNode *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"D_ParseNodePtr::val",
			"dpn", "D_ParseNodePtr");
#line 309 "D.xs"
	start 	= dpn->start_loc.s;
	end 	= dpn->end;
	len 	= end - start;
	DBG(1, warn("==dpn_val get"));
        if(len > 0) {
	  RETVAL = newSVpv(start, len);
	} else {
	  XSRETURN_UNDEF;
	}
#line 735 "D.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_D_ParseNodePtr_globals); /* prototype to pass -Wmissing-prototypes */
XS(XS_D_ParseNodePtr_globals)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "pn, ...");
    if (items == 2)
    {
	D_ParseNode*	pn;
#line 327 "D.xs"
	SV* val = SvREFCNT_inc(ST(1));
#line 758 "D.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "D_ParseNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pn = INT2PTR(D_ParseNode *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"D_ParseNodePtr::globals",
			"pn", "D_ParseNodePtr");
#line 329 "D.xs"
        pn->globals = newSVsv(val);
	RETVAL = val;
	DBG(1, warn("==dpn_globals put\t\tdpn@%x=(globals*%x<#%d)\n", pn, pn->globals, SvREFCNT(pn->globals)));
#line 773 "D.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    else
    {
	D_ParseNode*	pn;
	SV*	val;
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "D_ParseNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pn = INT2PTR(D_ParseNode *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"D_ParseNodePtr::globals",
			"pn", "D_ParseNodePtr");
#line 338 "D.xs"
	RETVAL = newSVsv(pn->globals);
	DBG(1, warn("==dpn_globals get\t\tdpn@%x=(globals*%x<#%d)\n", pn, pn->globals, SvREFCNT(pn->globals)));
#line 794 "D.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_D_ParseNodePtr_d_get_number_of_children); /* prototype to pass -Wmissing-prototypes */
XS(XS_D_ParseNodePtr_d_get_number_of_children)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dpn");
    {
	D_ParseNode*	dpn;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "D_ParseNodePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    dpn = INT2PTR(D_ParseNode *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"D_ParseNodePtr::d_get_number_of_children",
			"dpn", "D_ParseNodePtr");
#line 349 "D.xs"
  RETVAL = d_get_number_of_children(dpn);
#line 827 "D.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ParserPtr_loc); /* prototype to pass -Wmissing-prototypes */
XS(XS_ParserPtr_loc)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "p, ...");
    if (items == 2)
    {
	Parser*	p;
#line 368 "D.xs"
  SV* val = ST(1);
#line 849 "D.c"
	d_loc_t *	RETVAL;

	if (sv_derived_from(ST(0), "ParserPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Parser *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ParserPtr::loc",
			"p", "ParserPtr");
#line 370 "D.xs"
	DBG(1, warn("==loc_set\t\t\t\tp@%x=val=%x\n", p, val));
	StructCopy(INT2PTR(d_loc_t*, SvIV(val)), &(p->user.loc), d_loc_t);
	RETVAL = &(p->user.loc);
#line 864 "D.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "d_loc_tPtr", (void*)RETVAL);
    }
    else
    {
	Parser*	p;
	d_loc_t *	RETVAL;

	if (sv_derived_from(ST(0), "ParserPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Parser *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ParserPtr::loc",
			"p", "ParserPtr");
#line 378 "D.xs"
  DBG(1, warn("==loc_get\t\t\t\tp@%x~@%x(<#%i)\n"
	      , p, d_pl_interface(p), d_pl_interface(p) ? SvREFCNT(d_pl_interface(p)) : -1
	      )
      );
  RETVAL = &(p->user.loc);
#line 887 "D.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "d_loc_tPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ParserPtr_syntax_errors); /* prototype to pass -Wmissing-prototypes */
XS(XS_ParserPtr_syntax_errors)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "p, ...");
    if (items == 2)
    {
	Parser*	p;
#line 392 "D.xs"
  int val;
#line 910 "D.c"
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ParserPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Parser *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ParserPtr::syntax_errors",
			"p", "ParserPtr");
#line 394 "D.xs"
	val = (int)SvIV(ST(1));
	DBG(1, warn("=>syntax_errors_set\t\tp@%x=%ld\n", p, p));
  p->user.syntax_errors = val;
  RETVAL = val;
#line 927 "D.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    else
    {
	Parser*	p;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "ParserPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Parser *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ParserPtr::syntax_errors",
			"p", "ParserPtr");
#line 403 "D.xs"
  DBG(1, warn("=>syntax_errors_get\t\t\tp@%x=%d\n", p, p->user.syntax_errors));
  RETVAL = p->user.syntax_errors;
#line 947 "D.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ParserPtr_free_D_Parser); /* prototype to pass -Wmissing-prototypes */
XS(XS_ParserPtr_free_D_Parser)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	Parser*	p;
#line 414 "D.xs"
	int i;
#line 968 "D.c"

	if (sv_derived_from(ST(0), "ParserPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Parser *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ParserPtr::free_D_Parser",
			"p", "ParserPtr");
#line 416 "D.xs"
	i = d_pl_interface(p) ? SvREFCNT(d_pl_interface(p)) : -1;
  if(i < 0 || i > 4 || d_debug_level > 2) {
    warn("=>free_D_Parser\t\t\t\tp@%x~@%x(<#%i)\n", p, d_pl_interface(p), i);
  }
  if(i >= 0) {
    /* yeaky casting...check in parser.c!
     * opposite of dparser_make(); (new_D_Parser)...
     * actually only free is count is low!
     */
    SvREFCNT_dec(d_pl_interface(p));
    /* this has been a sub-parser.
     * it will be free when USE_GC is defined.
     * check free_D_Parser()
     */
  } else {
    /* shall never happen since this function is called when 
     * p-interface exists.
     */
  }
#line 998 "D.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_ParserPtr_interface); /* prototype to pass -Wmissing-prototypes */
XS(XS_ParserPtr_interface)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	Parser*	p;
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "ParserPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Parser *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ParserPtr::interface",
			"p", "ParserPtr");
#line 442 "D.xs"
	DBG(1, warn("==dparser_interface\t\t\tp@%x~@%x(<#%i)\n"
	   , p, d_pl_interface(p), d_pl_interface(p) ? SvREFCNT(d_pl_interface(p)) : -1));
	RETVAL = SvREFCNT_inc(d_pl_interface(p));
#line 1030 "D.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_ParserPtr_tables); /* prototype to pass -Wmissing-prototypes */
XS(XS_ParserPtr_tables)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	Parser*	p;
	D_ParserTables *	RETVAL;

	if (sv_derived_from(ST(0), "ParserPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Parser *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ParserPtr::tables",
			"p", "ParserPtr");
#line 454 "D.xs"
	DBG(1, warn("==dparser_tables\t\tp@%x~@%x(<#%i)\n"
	, p, d_pl_interface(p), d_pl_interface(p) ? SvREFCNT(d_pl_interface(p)) : -1));
  RETVAL = d_dpt(p);
#line 1064 "D.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "D_ParserTablesPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_ParserPtr_bless_interface); /* prototype to pass -Wmissing-prototypes */
XS(XS_ParserPtr_bless_interface)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "p");
    {
	Parser*	p;
#line 466 "D.xs"
	SV* s_rv;
#line 1086 "D.c"

	if (sv_derived_from(ST(0), "ParserPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    p = INT2PTR(Parser *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"ParserPtr::bless_interface",
			"p", "ParserPtr");
#line 468 "D.xs"
	s_rv = d_pl_interface(p);
  if(s_rv == Nullsv) {
    warn("==dparser_bless_interface:ERROR found a Parser* without an interface?!\n");
    return;
  } else {
    Parser* p_old = INT2PTR(Parser*, SvIV(SvRV(*hv_fetch((HV*)SvRV(s_rv), "this", 4, 0))));
    if(p_old != p) {
      /* then this object needs to be duplicated?! */
      // well I do not really know!
      // but at least make a copy of the refrence RV
      // or the HV*?!
      DBG(1, warn("==dparser_bless_interface:\t\t\thv(<#%i)rv(<#%i)\n", SvREFCNT(SvRV(s_rv)), SvREFCNT(s_rv)));
      p->pinterface1 = newSVsv(s_rv);
    } else {
      SvREFCNT_inc(d_pl_interface(p));
    }
  }
	DBG(1, warn("<=dparser_bless_interface\t\t\tp@%x~@%x(<#%i)\n", p, d_pl_interface(p) \
	   , d_pl_interface(p) ? SvREFCNT(d_pl_interface(p)) : -1));
#line 1116 "D.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Parser__D_make); /* prototype to pass -Wmissing-prototypes */
XS(XS_Parser__D_make)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "s, dpt, start_symbol");
    {
	HV*	s;
	D_ParserTables*	dpt;
	char*	start_symbol = (char *)SvPV_nolen(ST(2));
#line 504 "D.xs"
	int i = 0;
	/* in fact new_D_Parser is not cast to the right structure... */
	Parser* p;
	D_Parser* dp;
#line 1141 "D.c"
	Parser *	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    s = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"Parser::D::make",
			"s");

	if (sv_derived_from(ST(1), "D_ParserTablesPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    dpt = INT2PTR(D_ParserTables *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Parser::D::make",
			"dpt", "D_ParserTablesPtr");
#line 509 "D.xs"
     	p = (Parser*) new_D_Parser(dpt, sizeof(D_ParseNode_User));
	dp = &p->user;
	sIVhv(dp, fixup_EBNF_productions);
   	sIVhv(dp, save_parse_tree);
   	dp->initial_scope = NULL;
	sSVhv(dp, initial_globals);	
   	sIVhv(dp, dont_fixup_internal_productions);
   	sIVhv(dp, dont_merge_epsilon_trees);
   	sIVhv(dp, commit_actions_interval);
   	sIVhv(dp, partial_parses);
   	sIVhv(dp, dont_compare_stacks);
   	sIVhv(dp, dont_use_eagerness_for_disambiguation);
        sIVhv(dp, use_greedyness_for_disambiguation);
   	sIVhv(dp, dont_use_height_for_disambiguation);
   	sIVhv(dp, error_recovery);
   	inthvIV(s, d_debug_level);
	p->pinterface1 = newRV((SV*)s);
        p->speculative_code = speculative_action;
        p->final_code = final_action;
   	dp->free_node_fn = free_node_fn;
   	dp->initial_white_space_fn = initial_white_space_fn;
   	dp->syntax_error_fn = syntax_error_fn;
   	dp->ambiguity_fn = ambiguity_fn;
	/* this is the magic of object reallocation */
  	if(*start_symbol) {
	  for(i = 0; i < dpt->nsymbols; i++) {
	    if(dpt->symbols[i].kind == D_SYMBOL_NTERM
	       && strcmp(dpt->symbols[i].name, start_symbol) == 0) {
	      dp->start_state = dpt->symbols[i].start_symbol;
	      break;
	    }
	  }
	  if(i == dpt->nsymbols) {
	    warn("<=make\t\t\tinvalid start symbol@x%lx[#%d]:%s\n", dpt, i, start_symbol);
	  }
	}
        /*TODO remap also actions indexes here ? */
   	RETVAL = p;
#line 1198 "D.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ParserPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Parser__D_version); /* prototype to pass -Wmissing-prototypes */
XS(XS_Parser__D_version)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 554 "D.xs"
    char v[0x10];
#line 1219 "D.c"
	char *	RETVAL;
	dXSTARG;
#line 556 "D.xs"
    d_version(v);
    RETVAL = v;
#line 1225 "D.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Parser__D_dparse); /* prototype to pass -Wmissing-prototypes */
XS(XS_Parser__D_dparse)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "s, i, l");
    {
	HV*	s;
	int	i = (int)SvIV(ST(1));
	STRLEN	l = (STRLEN)SvUV(ST(2));
#line 569 "D.xs"
	Parser* p;
	char* buf;
#line 1249 "D.c"
	D_ParseNode *	RETVAL;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    s = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"Parser::D::dparse",
			"s");
#line 572 "D.xs"
	p = INT2PTR(Parser*, SvIV(SvRV(*hv_fetch(s, "this", 4, 0))));
	buf = SvPV_nolen(SvRV(*hv_fetch(s, "buf_start", 9, 0)));
        d_verbose_level = SvIV(*hv_fetch(s, "d_verbose_level", sizeof("d_verbose_level") - 1, 1));
	DBG(1, warn("==dparse\t\t\t\tp@%x s@%x:%s l=%d\n",p,buf+i,buf+i,l));
	RETVAL = dparse((D_Parser*)p, buf+i, l);
#line 1264 "D.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "D_ParseNodePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_GrammarPtr_register_fatal); /* prototype to pass -Wmissing-prototypes */
XS(XS_GrammarPtr_register_fatal)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "fn");
    {
	SV *	fn = ST(0);
#line 601 "D.xs"
         /* Remember the Perl sub */
         if (exit_callback == (SV*)NULL)
           exit_callback = newSVsv(fn) ;
         else
           SvSetSV(exit_callback, fn) ;
         /* register the callback with the external library */
/* int i = atexit(exit_cb1) ;*/
#line 1292 "D.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_GrammarPtr_free_D_Grammar); /* prototype to pass -Wmissing-prototypes */
XS(XS_GrammarPtr_free_D_Grammar)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	Grammar*	g;

	if (sv_derived_from(ST(0), "GrammarPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    g = INT2PTR(Grammar *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"GrammarPtr::free_D_Grammar",
			"g", "GrammarPtr");
#line 615 "D.xs"
	DBG(1, warn("==free_D_Grammar\t\t\tg@%x*%x\n", g, *g));
        free_D_Grammar(g);
#line 1322 "D.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_GrammarPtr_print_rdebug_grammar); /* prototype to pass -Wmissing-prototypes */
XS(XS_GrammarPtr_print_rdebug_grammar)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, p");
    {
	Grammar*	g;
	char*	p = (char *)SvPV_nolen(ST(1));

	if (sv_derived_from(ST(0), "GrammarPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    g = INT2PTR(Grammar *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"GrammarPtr::print_rdebug_grammar",
			"g", "GrammarPtr");
#line 623 "D.xs"
	print_rdebug_grammar(g,p);
#line 1352 "D.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_GrammarPtr_new_D_Grammar); /* prototype to pass -Wmissing-prototypes */
XS(XS_GrammarPtr_new_D_Grammar)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "grammar_pathname");
    {
	char*	grammar_pathname = (char *)SvPV_nolen(ST(0));
	Grammar *	RETVAL;
#line 631 "D.xs"
	RETVAL = new_D_Grammar(grammar_pathname);
	DBG(1, warn("==new_D_Grammar\t\t\t\tg@%x*%x\n", RETVAL, *RETVAL));
#line 1374 "D.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "GrammarPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_GrammarPtr_write_binary_tables_to_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_GrammarPtr_write_binary_tables_to_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	Grammar*	g;
#line 641 "D.xs"
	unsigned char* str;
	STRLEN str_len;
	int i;
#line 1398 "D.c"
	SV *	RETVAL;

	if (sv_derived_from(ST(0), "GrammarPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    g = INT2PTR(Grammar *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"GrammarPtr::write_binary_tables_to_string",
			"g", "GrammarPtr");
#line 645 "D.xs"
	i = write_binary_tables_to_string(g, &str, &str_len);
	RETVAL = newSVpvn((char*)str, str_len * sizeof(unsigned char));
#line 1412 "D.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_GrammarPtr_write_binary_tables_to_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_GrammarPtr_write_binary_tables_to_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, fp");
    {
	Grammar*	g;
	FILE*	fp = PerlIO_findFILE(IoIFP(sv_2io(ST(1))));
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GrammarPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    g = INT2PTR(Grammar *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"GrammarPtr::write_binary_tables_to_file",
			"g", "GrammarPtr");
#line 656 "D.xs"
	RETVAL = write_binary_tables_to_file(g, fp);
#line 1446 "D.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_GrammarPtr_write_binary_tables); /* prototype to pass -Wmissing-prototypes */
XS(XS_GrammarPtr_write_binary_tables)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	Grammar*	g;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GrammarPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    g = INT2PTR(Grammar *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"GrammarPtr::write_binary_tables",
			"g", "GrammarPtr");
#line 665 "D.xs"
	RETVAL = write_binary_tables(g);
#line 1478 "D.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_GrammarPtr_write_c_tables); /* prototype to pass -Wmissing-prototypes */
XS(XS_GrammarPtr_write_c_tables)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "g");
    {
	Grammar*	g;
	int	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "GrammarPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    g = INT2PTR(Grammar *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"GrammarPtr::write_c_tables",
			"g", "GrammarPtr");
#line 673 "D.xs"
	RETVAL = write_c_tables(g);
#line 1510 "D.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_GrammarPtr_mkdparse); /* prototype to pass -Wmissing-prototypes */
XS(XS_GrammarPtr_mkdparse)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, grammar_pathname");
    {
	Grammar*	g;
	char*	grammar_pathname = (char *)SvPV_nolen(ST(1));

	if (sv_derived_from(ST(0), "GrammarPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    g = INT2PTR(Grammar *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"GrammarPtr::mkdparse",
			"g", "GrammarPtr");
#line 683 "D.xs"
	mkdparse(g, grammar_pathname);
#line 1541 "D.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_GrammarPtr_mkdparse_from_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_GrammarPtr_mkdparse_from_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "g, s");
    {
	Grammar*	g;
	char*	s = (char *)SvPV_nolen(ST(1));

	if (sv_derived_from(ST(0), "GrammarPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    g = INT2PTR(Grammar *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"GrammarPtr::mkdparse_from_string",
			"g", "GrammarPtr");
#line 690 "D.xs"
	mkdparse_from_string(g, s);
#line 1571 "D.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Parser__D__Gammar_update_constantes); /* prototype to pass -Wmissing-prototypes */
XS(XS_Parser__D__Gammar_update_constantes)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "s, g");
    {
	HV*	s;
	Grammar*	g;

	if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0)))==SVt_PVHV)
	    s = (HV*)SvRV(ST(0));
	else
	    Perl_croak(aTHX_ "%s: %s is not a hash reference",
			"Parser::D::Gammar::update_constantes",
			"s");

	if (sv_derived_from(ST(1), "GrammarPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    g = INT2PTR(Grammar *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Parser::D::Gammar::update_constantes",
			"g", "GrammarPtr");
#line 721 "D.xs"
	/* grammar construction options */
	IV_2_g(states_for_whitespace);
	IV_2_g(states_for_all_nterms);
	IV_2_g(set_op_priority_from_rule);
	IV_2_g(right_recursive_BNF);
	IV_2_g(tokenizer);
	IV_2_g(longest_match);
	/* grammar writing options */
	cpyPVhv(g,grammar_ident);
	cpyPVhv(g,write_extension);
	IV_2_g(scanner_blocks);
	IV_2_g(scanner_block_size);
	IV_2_g(write_line_directives);
	IV_2_g(write_header);
	IV_2_g(token_type);
	/* don't print anything to stdout, when the grammar is printed there */
        d_verbose_level = SvIV(*hv_fetch(s, "d_verbose_level", sizeof("d_verbose_level") - 1, 1));
        d_rdebug_grammar_level = SvIV(*hv_fetch(s, "d_rdebug_grammar_level", sizeof("d_rdebug_grammar_level") - 1, 1));
	if (d_rdebug_grammar_level > 0) d_verbose_level = 0;
        //# no cant do that it has been set up in new_D_grammar anyway...
        //#PV_2_g(pathname);
#line 1628 "D.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Parser__D); /* prototype to pass -Wmissing-prototypes */
XS(boot_Parser__D)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("D_ParserTablesPtr::free", XS_D_ParserTablesPtr_free, file);
        newXS("D_ParserTablesPtr::dump", XS_D_ParserTablesPtr_dump, file);
        newXS("D_ParserTablesPtr::symbol_name", XS_D_ParserTablesPtr_symbol_name, file);
        newXS("Parser::D::Tables::read_binary", XS_Parser__D__Tables_read_binary, file);
        newXS("Parser::D::Tables::read_binary_from_file", XS_Parser__D__Tables_read_binary_from_file, file);
        newXS("Parser::D::Tables::read_binary_from_string", XS_Parser__D__Tables_read_binary_from_string, file);
        (void)newXSproto_portable("Parser::D::d_loc_t::s_get", XS_Parser__D__d_loc_t_s_get, file, "$");
        (void)newXSproto_portable("Parser::D::d_loc_t::s_set", XS_Parser__D__d_loc_t_s_set, file, "$$");
        (void)newXSproto_portable("Parser::D::d_loc_t::col_get", XS_Parser__D__d_loc_t_col_get, file, "$");
        (void)newXSproto_portable("Parser::D::d_loc_t::line_get", XS_Parser__D__d_loc_t_line_get, file, "$");
        (void)newXSproto_portable("D_ParseNodePtr::children_list", XS_D_ParseNodePtr_children_list, file, "$");
        (void)newXSproto_portable("D_ParseNodePtr::user", XS_D_ParseNodePtr_user, file, "$;@");
        (void)newXSproto_portable("D_ParseNodePtr::action_index", XS_D_ParseNodePtr_action_index, file, "$");
        (void)newXSproto_portable("D_ParseNodePtr::speculative_code", XS_D_ParseNodePtr_speculative_code, file, "$");
        (void)newXSproto_portable("D_ParseNodePtr::final_code", XS_D_ParseNodePtr_final_code, file, "$");
        (void)newXSproto_portable("D_ParseNodePtr::symbol", XS_D_ParseNodePtr_symbol, file, "$;@");
        (void)newXSproto_portable("D_ParseNodePtr::val", XS_D_ParseNodePtr_val, file, "$");
        (void)newXSproto_portable("D_ParseNodePtr::globals", XS_D_ParseNodePtr_globals, file, "$;@");
        (void)newXSproto_portable("D_ParseNodePtr::d_get_number_of_children", XS_D_ParseNodePtr_d_get_number_of_children, file, "$");
        (void)newXSproto_portable("ParserPtr::loc", XS_ParserPtr_loc, file, "$;@");
        (void)newXSproto_portable("ParserPtr::syntax_errors", XS_ParserPtr_syntax_errors, file, "$;@");
        (void)newXSproto_portable("ParserPtr::free_D_Parser", XS_ParserPtr_free_D_Parser, file, "$");
        (void)newXSproto_portable("ParserPtr::interface", XS_ParserPtr_interface, file, "$");
        (void)newXSproto_portable("ParserPtr::tables", XS_ParserPtr_tables, file, "$");
        (void)newXSproto_portable("ParserPtr::bless_interface", XS_ParserPtr_bless_interface, file, "$");
        (void)newXSproto_portable("Parser::D::make", XS_Parser__D_make, file, "$$$");
        (void)newXSproto_portable("Parser::D::version", XS_Parser__D_version, file, "");
        (void)newXSproto_portable("Parser::D::dparse", XS_Parser__D_dparse, file, "$$$");
        (void)newXSproto_portable("GrammarPtr::register_fatal", XS_GrammarPtr_register_fatal, file, "$");
        (void)newXSproto_portable("GrammarPtr::free_D_Grammar", XS_GrammarPtr_free_D_Grammar, file, "$");
        (void)newXSproto_portable("GrammarPtr::print_rdebug_grammar", XS_GrammarPtr_print_rdebug_grammar, file, "$$");
        (void)newXSproto_portable("GrammarPtr::new_D_Grammar", XS_GrammarPtr_new_D_Grammar, file, "$");
        (void)newXSproto_portable("GrammarPtr::write_binary_tables_to_string", XS_GrammarPtr_write_binary_tables_to_string, file, "$");
        (void)newXSproto_portable("GrammarPtr::write_binary_tables_to_file", XS_GrammarPtr_write_binary_tables_to_file, file, "$$");
        (void)newXSproto_portable("GrammarPtr::write_binary_tables", XS_GrammarPtr_write_binary_tables, file, "$");
        (void)newXSproto_portable("GrammarPtr::write_c_tables", XS_GrammarPtr_write_c_tables, file, "$");
        (void)newXSproto_portable("GrammarPtr::mkdparse", XS_GrammarPtr_mkdparse, file, "$$");
        (void)newXSproto_portable("GrammarPtr::mkdparse_from_string", XS_GrammarPtr_mkdparse_from_string, file, "$$");
        (void)newXSproto_portable("Parser::D::Gammar::update_constantes", XS_Parser__D__Gammar_update_constantes, file, "$$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

